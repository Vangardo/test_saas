#!/usr/bin/python# -*- coding: utf-8 -*-from configs.config import AppConfigimport psycopg2import psycopg2.extensionsimport timeDEBUG_SQL = Trueclass dotDict(dict):    """dot.notation access to dictionary attributes"""    __getattr__ = dict.get    __setattr__ = dict.__setitem__    __delattr__ = dict.__delitem__    def __getattr__(self, item: str):        # return self.__class__(self.get(item))        val = self.get(item)        if type(val) == dict:            return self.__class__(self.get(item))        else:            return valclass _WrapperMap:    def __init__(self, d: dict):        self.d = d    # def get_value(self):    #     return self.d    def __getattr__(self, item: str) -> 'WrapperMap':        val = self.d.get(item)        if type(val) == int:            return val        if type(val) == str:            return val        else:            return self.__class__(self.d.get(item))    def __repr__(self):        return repr(self.d)def cur_execute(*params):    conn = connect_base()    cur = conn.cursor()    psycopg2.extensions.register_type(psycopg2.extensions.UNICODE, cur)    par = True    try:        cur.execute(*params)        prm = params[0].split()[0].lower()        if prm in ['update','insert','delete','create','drop','alter','do']: conn.commit()    except Exception as par:        if DEBUG_SQL:            print(par)            TRACE = str(par) + '\n'            T = '%04d-%02d-%02d %02d:%02d:%02d\n' % time.localtime()[:6]            T += TRACE            # appendfile(ERR_FILE, T)        par = None        conn.rollback()    cur.close()    conn.close()    return pardef cur_execute_fetchone(*params):    # SQL = 'insert into log (date, description) values (%s, %s)'    # cur_execute(SQL, (datetime.datetime.now(), params))    conn = connect_base()    try: cur = conn.cursor()    except: return None    psycopg2.extensions.register_type(psycopg2.extensions.UNICODE, cur)    par = None    try:        cur.execute(*params)        prm = params[0].split()[0].lower()        if prm in ['update','insert','delete','create','drop','alter']: conn.commit()        try:            par = cur.fetchone()            if par:                names = [x[0].lower() for x in cur.description]                REZ = dict(zip(names, par))                REZ = dotDict(REZ)            else:                REZ = None        except Exception as par:            if DEBUG_SQL:                print(par)                TRACE = str(par) + '\n'                T = '%04d-%02d-%02d %02d:%02d:%02d\n' % time.localtime()[:6]                T += TRACE                # appendfile(ERR_FILE, T)            par = None    except Exception as par:        if DEBUG_SQL:            print(par)            TRACE = str(par) + '\n'            T = '%04d-%02d-%02d %02d:%02d:%02d\n' % time.localtime()[:6]            T += TRACE            # appendfile(ERR_FILE, T)        REZ = None        conn.rollback()    cur.close()    conn.close()    return REZdef sql_fetchall(SQL):    conn = connect_base()    try:        cur = conn.cursor()    except:        return None    psycopg2.extensions.register_type(psycopg2.extensions.UNICODE, cur)    cur.execute(SQL)    prm = SQL.split()[0].lower()    if prm in ['update', 'with', 'insert', 'delete', 'create', 'drop', 'alter']: conn.commit()    par = cur.fetchall()    if par:        names = [x[0].lower() for x in cur.description]        par = [dotDict(dict(zip(names, x))) for x in par]    cur.close()    conn.close()    return pardef cur_execute_fetchall(SQL, params, dotAccess=True):    # SQL = 'insert into log (date, description) values (%s, %s)'    # cur_execute(SQL, (datetime.datetime.now(), params))    conn = connect_base()    try: cur = conn.cursor()    except: return None    psycopg2.extensions.register_type(psycopg2.extensions.UNICODE, cur)    par = None    try:        cur.execute(SQL, params)        prm = SQL.split()[0].lower()        if prm in ['update','insert','delete','create','drop','alter']: conn.commit()        try:            par = cur.fetchall()            if par:                names = [x[0].lower() for x in cur.description]                if dotAccess:                    par = [dotDict(dict(zip(names, x))) for x in par]                else:                    par = [dict(zip(names, x)) for x in par]        except Exception as par:            if DEBUG_SQL:                print(par)                # TRACE = str(par) + '\n'                # T = '%04d-%02d-%02d %02d:%02d:%02d\n' % time.localtime()[:6]                # T += TRACE                # appendfile(ERR_FILE, T)            par = None    except Exception as par:        if DEBUG_SQL:            print(par)            TRACE = str(par) + '\n'            T = '%04d-%02d-%02d %02d:%02d:%02d\n' % time.localtime()[:6]            T += TRACE            # appendfile(ERR_FILE, T)        par = None        conn.rollback()    cur.close()    conn.close()    return pardef connect_base():    config = AppConfig()    base_name = config.psql.base    base_user = config.psql.login    base_pass = config.psql.passwd    base_port = config.psql.port    base_host = config.psql.host    conn = psycopg2.connect(database=base_name, user=base_user, host=base_host, password=base_pass, port=base_port)    return conndef addQueryField(query, name, value=None, isKey=False, skipParameter=False, isFilter=False):    query[name] = {"value": value, "isKey": isKey, "skipParameter": skipParameter, "isFilter": isFilter}def generateInsertRequest(query, tableName, conflictResolve=False, conflictCondition=None, handleConflict=False):    SQL = "insert into %s (" % tableName    par = []    parStr = ''    for item in query:        SQL += "%s, " % item        if query[item]['skipParameter']:            parStr += '%s,' % query[item]['value']        else:            parStr += '%s,'            par.append(query[item]['value'])    SQL = '%s) values (%s)' % (SQL[:-2], parStr[:-1])    if handleConflict:        SQL = "%s ON CONFLICT (" % SQL        for item in query:            if query[item]['isKey']:                SQL += "%s, " % item        SQL = "%s)" % SQL[:-2]        if conflictCondition:            SQL = "%s %s" % (SQL, conflictCondition)        if conflictResolve:            SQL = "%s %s" % (SQL, conflictResolve)    return SQL, tuple(par)def generateBulkInsertRequest(queryList=[], tableName=''):    SQL = "insert into %s (" % tableName    par = []    parStr = ''    query = queryList[0]    for item in query:        SQL += "%s, " % item        parStr += '%s,'    for query in queryList:        for item in query:            par.append(query[item]['value'])    SQL = '%s) values ' % SQL[:-2]    for query in queryList:        SQL += '(%s), ' % parStr[:-1]    SQL = SQL[:-2] + 'ON CONFLICT DO NOTHING'    return SQL, tuple(par)    passdef generateUpdateRequest(query, tableName):    SQL = "update %s set " % tableName    parStr = ''    filterStr = ''    par = []    filterPar = []    for item in query:        if query[item]['isFilter']:            filterStr += '%s=%s and ' % (item, '%s')            filterPar.append(query[item]['value'])        else:            if query[item]['skipParameter']:                parStr += '%s=%s, ' % (item, query[item]['value'])            else:                parStr += '%s=%s, ' % (item, '%s')                par.append(query[item]['value'])    SQL = '%s %s where %s' % (SQL, parStr[:-2], filterStr[:-5])    for item in filterPar:        par.append(item)    return SQL, tuple(par)def generateSelectRequest(query, tableName, filter, fields):    SQL = "select %s from %s" % (''.join(fields), tableName)    if filter:        SQL = '%s where ' % SQL        par = []        for item in filter:            SQL += "%s=%s and " % (item, '%s')            par.append(filter[item])        SQL = SQL[:-5]    else:        par = ()    return SQL, tuple(par)def getSqlData(tableName, fields='', filter='', dotAccess=True, sort='', single=False):    query = {}    if not fields: fields = ('*',)    for field in fields:        addQueryField(query=query, name=field)    SQL, par = generateSelectRequest(query=query, tableName=tableName, filter=filter, fields=fields)    if sort:        SQL += ' order by %s' % sort    res = cur_execute_fetchall(SQL, par, dotAccess)    if single:        if len(res) == 1:            return res[0]        else:            raise SystemError    return res    pass